[TOC]

##### 如何设计一个用户表：

三种设计方法：
1 大表设计思路 将用户相关的信息都设计在一张用户表中 
2 常用和不常用做分离设计 将用户常用的和不常用的做分离设计，这样可以达到更好的性能，比如说用户详细信息，只有用户编辑个人信息时才会修改，用户在使用其他功能时，是不需要这部分的； 
3 按用户类型做分离设计 用户ID，用户名，密码；等基本信息放在一个表中，这样满足不同应用的需求，将不同用户独有的信息设计到不同的表中，和基本信息表1对1关系
举例：
用户现有  老师  学生  家长 按照设计思路1： 用户表是老师，学生，家长三个实体属性的并集，并且有一个用户类型字段，标识不同的用户 User(userID，..........userType) 
优点：可以减少数据库请求次数 缺点：用户表的写锁频率较高 
按照设计思路2： 将使用频繁的用户属性和只在特定场景才会使用的用户属性，分离至不同的表 
优点：用户表基本无更新操作，所以无写锁 缺点： User（userID,userName,userType,email，password） UserDetail(userID,gender,portrait,accountStatus,level,score,address,telephone,degree,college) 
按照设计思路3： 
将表分为用户表，老师表，学生表，家长表，其中用户表分别和老师表，学生表，家长表，一对一关系 用户表只存最基本的信息，登录名，密码，用户ID User(userID,loginName,password)  Teacher(userID,school,course)    Student(userID,school,grade,class)    Parent(userID,address,occupation,age) 
优点：利于拓展某一类型用户 缺点：由于修改不同用户的信息时，要操作不同的表，程序逻辑略微复杂； 问题主要是关于用户表的设计，如何设计最为合理 1 是否分表 2 依据什么分表，用户类型还是面向业务的使用频率



##### 职业规划

```
前一到两年做一些增删改查的小模块，尽快融入到工作环境中去之后研究一些复杂的逻辑模块，再做核心模块编写；

当基础技术成熟的时候研究各种框架的源码，性能调优、Spring，JVM等技术，走向工程师阶段。

当有一定时间沉淀的时候再向架构师发展。
```

##### 1.spring mvc的配置：

    1.建立一个普通法的web项目
    
    2.引入相关jar包
    
    3.在web的配置文件web.xml中配置mvc的相关配置和dispatchServlet

##### 2.springboot的配置

    1.在spring官网start.spring.io快速创建一个项目
    
    2.在maven引入相关的依赖
    
    3.在application文件中管理springboot配置

##### 3.nosql：

NoSQL，泛指非关系型的数据库。

##### nosql的特点

    1.不需要预定义模式
    
    2.无共享架构
    
    3.弹性可扩展
    
    4.分区
    
    5.异步复制

##### nosql的使用场景

    1、数据模型比较简单；
    
    2、需要灵活性更强的IT系统；
    
    3、对数据库性能要求较高；
    
    4、不需要高度的数据一致性；
    
    5、对于给定key，比较容易映射复杂值的环境。

##### 4.GitHub上传的命令

1).初次上传的时候:

```
1.git init 

2.git add . 

3.git commit -m "起个名字"

4.git remote add origin 你的网址

5.git push -u origin master
```

2).二次上传的时候

```
1.git add .

2.git commit -m "起个名字“

3.git push -u origin master
```

   git回退:

	本地:git reset --hard 版本号
	
	同步回退:git push --force

   git分支:

	1.创建并切换分支 :git checkout -b 名字
	
	2.创建分支 ： git branch 名字
	
	3.查看分支：git branch
	
	4.选择分支：git checkout 名字
	
	5.合并分支：git merge 分支名字
	
	6.删除分支：git branch -d 名字

##### Maven常见的依赖范围有哪些?

compile:编译依赖，默认的依赖方式，在编译（编译项目和编译测试用例），运行测试用例，运行（项目实际运行）三个阶段都有效，典型地有spring-core等jar。

	test:测试依赖，只在编译测试用例和运行测试用例有效，典型地有JUnit。
	
	provided:对于编译和测试有效，不会打包进发布包中，典型的例子为servlet-api,一般的web工程运行时都使用容器的servlet-api。
	
	runtime:只在运行测试用例和实际运行时有效，典型地是jdbc驱动jar包。
	
	system: 不从maven仓库获取该jar,而是通过systemPath指定该jar的路径。
	
	import: 用于一个dependencyManagement对另一个dependencyManagement的继承。

##### “Mvn Clean Package”命令进行项目打包，请问该命令执行了哪些动作来完成该任务？

```
maven-clean-plugin:clean

maven-resources-plugin:resources

maven-compile-plugin:compile

mavne-resources-plugin:testResources

maven-compile-plugin:testCompile

maven-jar-plugin:jar
```

##### Java设计原则：

```
1.不要把所有的逻辑代码写到单独的方法中，把小的逻辑代码独立出来，要易读，可复用

2.写类，写方法，写功能时，应考虑其移植性，复用性：防止一次性代码！

3.找出应用中相同之处，且不容易发生变化的东西，把它们抽取到抽象类中，让子类去继承它们；
```

##### Java设计模式：

1.单例模式

```
是一种常用的软件设计模式，在它的核心结构中值包含一个被称为单例的特殊类。一个类只有一个实例，即一个类只有一个对象实例。
```

2.工厂模式

```
根据需要返回我们的对象。应用比较熟悉的场景就是spring配置文件了。
```

3.适配器模式

```
将一个类的接口转换成客户希望的另外一个接口。通俗地讲，就是在2个类之间做了一个衔接。比如你在调用A类的doSomething方法，实际上内部实现调用了B类的doSomething方法。
```

4.代理模式

```
它的定义是：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。Java的反射机制，很多地方就用了代理模式来实现。
```

5.监听模式

```
当事件源触发某种行为，会自动执行事件监听器里面相应的方法。
Java监听模式右三个部分组成：事件源、事件对象、事件监听器。
```

6.装饰器模式

```
简单说就是不改变现有类的结构前提下，扩展它的功能。用别的类来增加原有类的功能。
```

##### 数据库各种连接：

1.内连接

内连接就是两张表中都包含的数据，因为部门表包含了员工表，所以内连接就是上图中绿色部分

```sql
SELECT * FROM tbl_dept a INNER JOIN tbl_emp b ON a.id = b.deptId;
```

2.左外连接

左外连接就是查询join左边表中的所有数据，并且把join右边表中对应的数据查询出来

```sql
SELECT * FROM tbl_dept a LEFT JOIN tbl_emp b ON a.id=b.deptId;
```

3.左连接

其实就是在左外连接在后面加了一个where条件，查询只存在于join左边表的内容

```sql
SELECT * FROM tbl_dept a LEFT JOIN tbl_emp b ON a.id=b.deptId WHERE b.deptId IS NULL;
```

4.全连接

```sql
SELECT * FROM tbl_dept a RIGHT JOIN tbl_emp b ON a.id=b.deptId 
UNION 
SELECT * FROM tbl_dept a LEFT JOIN tbl_emp b ON a.id=b.deptId;
```

5.--两张表中都没有同时出现的数据集

```sql
SELECT * FROM tbl_dept a RIGHT JOIN tbl_emp b ON a.id=b.deptId WHERE a.id IS NULL
UNION 
SELECT * FROM tbl_dept a LEFT JOIN tbl_emp b ON a.id=b.deptId  WHERE b.deptId IS NULL;
```

##### 三个范式(通俗地理解是够用的理解，并不是最科学最准确的理解)： 

   	

```
   第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；

　　第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性

　　第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余
```



##### 范式优点

```
1）范式化的数据库更新起来更加快；

2）范式化之后，只有很少的重复数据，只需要修改更少的数据；

3）范式化的表更小，可以在内存中执行；

4）很少的冗余数据，在查询的时候需要更少的distinct或者group by语句。
```



##### 范式缺点

```
1）范式化的表，在查询的时候经常需要很多的关联，因为单独一个表内不存在冗余和重复数据。这导致，稍微复杂一些的查询语句在查询范式的schema上都可能需要较多次的关联。这会增加让查询的代价，也可能使一些索引策略无效。因为范式化将列存放在不同的表中，而这些列在一个表中本可以属于同一个索引。
```



##### 反范式的优点：

```
1）可以避免关联，因为所有的数据几乎都可以在一张表上显示；
2）可以设计有效的索引；
```



##### 反范式的缺点：

```
表格内的冗余较多，删除数据时候会造成表有些有用的信息丢失。
所以在设计数据库时，要注意混用范式化和反范式化。
```

##### 数据库设计原则

```
1.适度冗余， 让query（查询）尽量减少join（连接）

2.大字段垂直分拆

3.大表水平分拆

4.选择合适的数据类型
```

##### Linux命令行：

连接服务器：ssh root@网址

查看文件列表：ls

返回主目录：cd /

返回上一级：cd ..

选择文件：cd /文件名

打开文件：vim /文件名

运行程序：./

创建文件夹：mkdir 文件名

创建文件：vim 文件名 或者 touch 文件名

vim操作：wq保存并退出  q!强制退出 

删除文件：rm 文件名

删除文件夹：rm -r -f 文件夹名

上传文件：scp 要传的文件路径 root@你的服务器地址：传到服务器的哪个文件

开启服务：systemctl start 你要开启的服务 

关闭服务：systemctl stop 你要关闭的服务

开机启动服务：systemctl enable 服务名

配置环境变量：vim /etc/profile

应用环境变量: source /etc/profile

暂时更改环境变量：export  环境变量名=环境变量值

##### nginx安装

```linu&#39;x
yum install nginx
```

##### Linux开启服务

```
systemctl start nginx
```

##### nginx部署前端

把写好的前端html文件复制到上传到nginx下的静态资源目录里面，通过文件名访问就可以了

##### nginx负载均衡

1.轮询（默认） 

2.weight

3.ip_hash

4.fair（第三方） 

##### nginx面试题

1、什么是Nginx? Nginx是一个高性能的HTTP和反向代理服务器，及电子邮件（IMAP/POP3）代理服务器，同时也是一个非常高效的反向代理、负载平衡。

2.为什么要用Nginx？非阻塞、高并发连接,内存消耗小,内置的健康检查功能

3.正向代理:代理端代理的是客户端

4.反向代理:代理端代理的是服务端

5.动态资源、静态资源分离：动态文件与静态文件的分离

6.负载均衡：负载均衡即是代理服务器将接收的请求均衡的分发到各服务器中     负载均衡主要解决网络拥塞问题，提高服务器响应速度，服务就近提供，达到更好的访问质量，减少后台服务器大并发压力

##### docker的命令

1.运行镜像

```
docker run --name nginx1 -p 8110:80 -v /usr/share/nginx/html:/usr/share/nginx/html -d nginx
```

2.dockerjar包镜像

```
docker  build -t "名字" .
```

##### AOP

AOP称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待，Struts2的拦截器设计就是基于AOP的思想，是个比较经典的例子。

AOP的基本概念

(1)Aspect(切面):通常是一个类，里面可以定义切入点和通知

(2)JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用

(3)Advice(通知):AOP在特定的切入点上执行的增强处理，有before,after,afterReturning,afterThrowing,around

(4)Pointcut(切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式

(5)AOP代理：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类

二 Spring AOP

Spring中的AOP代理还是离不开Spring的IOC容器，代理的生成，管理及其依赖关系都是由IOC容器负责，Spring默认使用JDK动态代理，在需要代理类而不是代理接口的时候，Spring会自动切换为使用CGLIB代理，不过现在的项目都是面向接口编程，所以JDK动态代理相对来说用的还是多一些。

三 基于注解的AOP配置方式

1.启用@AsjectJ支持

在applicationContext.xml中配置下面一句:

```xml
<aop:aspectj-autoproxy />
```

2.通知类型介绍

(1)Before:在目标方法被调用之前做增强处理,@Before只需要指定切入点表达式即可

(2)AfterReturning:在目标方法正常完成后做增强,@AfterReturning除了指定切入点表达式后，还可以指定一个返回值形参名returning,代表目标方法的返回值

(3)AfterThrowing:主要用来处理程序中未处理的异常,@AfterThrowing除了指定切入点表达式后，还可以指定一个throwing的返回值形参名,可以通过该形参名

来访问目标方法中所抛出的异常对象

(4)After:在目标方法完成之后做增强，无论目标方法时候成功完成。@After可以指定一个切入点表达式

(5)Around:环绕通知,在目标方法完成前后做增强处理,环绕通知是最重要的通知类型,像事务,日志等都是环绕通知,注意编程中核心是一个ProceedingJoinPoint

##### aop的用途

日志记录、事务控制、权限控制、性能统计、异常处理及事务处理

##### ORM框架

ORM（Object Relational Mapping）框架采用元数据来描述对象一关系映射细节，元数据一般采用XML格式，并且存放在专门的对象一映射文件中。

##### 数据库事务

**原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

**一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。

**隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。

**持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。数据库

##### 数据库创建索引

直接创建普通索引

```sql
CREATE INDEX index_name ON table(column(length))
```

修改表结构的方式添加普通索引

```sql
ALTER TABLE table_name ADD INDEX index_name ON (column(length))
```

添加唯一索引

```sql
ALTER TABLE table_name ADD UNIQUE ( column )
```

##### sql优化

```yi
1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描

3.应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。

4.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描

5.in 和 not in 也要慎用，对于连续的数值，能用 between 就不要用 in 了，很多时候用 exists 代替 in 是一个好的选择

6.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：

7..应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。

8.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。

9.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。

10.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 

11.不要写一些没有意义的查询，如需要生成一个空表结构

12.Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志

13.对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。

14.select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。

15.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。

16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。

17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

19.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。

20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。

21.避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。 

22.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。

23.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。

24.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。

25.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。

26.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。

27.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 

28.尽量避免大事务操作，提高系统并发能力。

29.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
```

